# Discord Modules
import discord
from discord.app_commands.tree import CommandTree
from discord.ext import commands
import discord.ext
import discord.ext.commands

# Default modules 
from datetime import datetime
from signal import signal, SIGHUP, SIGINT, SIGTERM
from asyncio import get_event_loop
from typing import Iterable, Any, Callable, Awaitable

# Modules from different files
from utils.settings import *
from app_commands.Staff import Staff


logger = logging.getLogger('bot')

# Checks if the bot is online, if yes sends a log message to logging channel
async def is_bot_ready():
    if bot.is_ready():
        logging_channel = bot.get_channel(LOGGING_CHANNEL)
        embed = discord.Embed(
            color=discord.Color.red(),
            description="I am up and running now!",
            timestamp= datetime.now()
        )
        await logging_channel.send(embed=embed)


# Sends a message when the bot is being shut down due to any critical reason or because of host disconnection
async def shutdown_message(message):
    logging_channel = bot.get_channel(LOGGING_CHANNEL)

    embed = discord.Embed(
        color=discord.Color.red(),
        description= message
    )
    await logging_channel.send(embed=embed)
    await bot.close()


# Loophole to add the signal handler as coroutine functions can't be called
def handle_exit(message: str):
    loop = get_event_loop()
    loop.create_task(shutdown_message(message))


# Main class that makes the bot
class Bot(commands.Bot):
    # This __init__ class is auto generated by VS Code so the programmer doesnt know shit whats going on in this
    def __init__(
            self, 
            command_prefix: Iterable[str] | str | Callable[[discord.ext.commands.Bot, discord.Message], Iterable[str] | str | Awaitable[Iterable[str] | str]],
            *, 
            tree_cls: CommandTree[Any] = CommandTree, 
            description: str | None = None, 
            intents: discord.Intents, 
            **options: Any
            ) -> None:
        

        super().__init__(
            command_prefix, 
            tree_cls=tree_cls, 
            description=description, 
            intents=intents, 
            **options
            )
        
        self.initial_extensions = [f'cogs.{cog[:-3]}' for cog in COGS if cog != "__init__.py" and cog.endswith('.py')]

    # Loads every cog in the cogs and voice_cogs directory 
    async def setup_hook(self):
        for extension in self.initial_extensions:
            try:
                await self.load_extension(extension)
            except Exception as e:
                logger.error(f'Error loading extension {extension}: {e}')
        
        staff_instance = Staff(self)
        self.tree.add_command(staff_instance)

        await self.tree.sync()


    async def on_ready(self):
        await self.change_presence(activity=discord.Game(name='Moderation'), status=discord.Status.dnd)
        
        logger.info(f"Logged in as {self.user} with ID {self.user.id}")
        await is_bot_ready()
        print('Bot is ready')


    async def on_member_join(self, member):
        welcome_channel = member.guild.get_channel(WELCOME_CHANNEL_ID)
        if welcome_channel:
            await welcome_channel.send(f'Welcome to the server, {member.mention}!\n'
                                       f'You joined on {datetime.now().strftime("%c")}\n'
                                       'bOnk')


    async def on_message(self, message: discord.Message):
        responses = ['blc profile', 'badlion profile', 'texture pack', 'resource pack', 'sb pack']
        if message.author == self.user: return
        
        for i in responses:
            if i in message.content:
                with open('images/readfaq.jpeg', 'rb') as faq:
                    await message.reply(file=discord.File(faq))
                    await message.channel.send('This is an automated message, please ignore if you did not ask about Intrest\'s profile')

        await self.process_commands(message)  # Ensure commands are still processed

    
# Signal handlers that check if any type of interuption has occured, if yes it shut downs the bot
# When Ctrl+C is entered (KeyboardInterrupt Error) into terminal
signal(SIGINT, lambda s, f: handle_exit("CTRL+C was pressed (Bot shutting down from terminal)"))


# Terminaltion signal
signal(SIGTERM, lambda s,f : handle_exit("Bot Shutting down for development"))


# Hangup detected on controlling terminal or death of controlling process
signal(SIGHUP, lambda s,f: handle_exit("Terminal closed, contact host to identify problem."))



# Calls the function that runs the bot
if __name__ == "__main__":  
    bot = Bot(command_prefix='bald', intents=discord.Intents.all())
    bot.run(TOKEN)